---
title: Hash and Keys
---

In computer science, a hash function is a mathematical function that maps data of arbitrary size to data of fixed size. The fixed-size output is commonly referred to as a hash value or hash code. One of the key properties of a hash function is that for a given input, it produces a unique hash value. This means even slight variations in input data result in vastly different output hash values.

## Properties of Hash Functions

- **Deterministic**: Hash functions are deterministic, meaning for the same input, they always produce the same output. This property makes hash functions widely applicable in various fields such as data structures, cryptographic algorithms, etc.
- **Fast Computation**: Hash functions typically compute output in very short time frames, making them suitable for processing large amounts of data and efficient data storage.
- **Irreversibility**: Reversing the process of obtaining the original input data from the hash value is difficult and often considered infeasible. This means even if the hash value is known, inferring the original input is challenging.
- **Discreteness**: Minor changes in input result in significant changes in output, ensuring the uniqueness of hash values. This makes hash functions excellent for unique identification of data.

## Applications of Hash in Data Integrity Verification

In the process of data storage and transmission, hash functions are commonly used to verify data integrity. The sender transforms the original data into a hash value using a hash function and sends it along with the received data to the recipient. The recipient applies the same hash function to the received data again, compares the generated hash value with the one provided by the sender to verify whether the data has been tampered with.

## Hash Applications in Blockchain

In blockchain, hash functions play a crucial role, used for:

- **Block Hash**: Each block contains the hash value of the previous block, forming a chain structure. The immutability of this hash chain ensures the security and transparency of the blockchain.
- **Transaction Hash**: Each transaction has a unique hash value used to verify the validity and integrity of transactions. These transaction hash values are also included in blocks.
- **Merkle Tree**: It's a tree-like data structure formed by calculating hash values of transaction hashes as leaf nodes. The root hash of the Merkle tree is written into the block header, used to verify all transactions included in the block.

## Hash Collision and Security

Despite widespread use in practical applications, hash functions still encounter the concept of hash collisions, where two different input data produce the same hash value. For applications requiring high security (such as cryptographic algorithms), hash collisions can lead to security vulnerabilities. Hence, modern hash function designs take into account prevention of collision occurrences.

## Public and Private Keys

In encryption technology, public and private keys are components of a key pair commonly used for encrypting and decrypting information, digital signatures, and authentication purposes.

In blockchain, public and private keys are also used for encrypting transactions of digital assets and performing authentication. Each participant has a unique public-private key pair used for securely managing and executing transactions. When a user initiates a transaction, they sign the transaction with their private key, and others can verify the validity of the signature using the public key.

### Public Key

The public key is generated by asymmetric encryption algorithms and can be shared publicly. It allows anyone to encrypt data using the public key, but only the corresponding private key can decrypt it.

### Private Key

The private key is the paired key with the public key, which must be kept secret. The private key is used for decrypting data encrypted by the public key and for digital signatures to prove the origin and integrity of data.

## Hash and Key Algorithms in Mgo

The core idea of Mgo is cryptographic agility. The system supports various cryptographic algorithms and primitives and can quickly switch between them. With Mgo, you can choose the appropriate encryption solution for your system and implement it when new algorithms are introduced.

Mgo unifies its cryptographic primitives (such as public keys, signatures, aggregated signatures, and hash functions) under a single type alias or enum wrapper shared across the entire repository. Changes to these primitives affect all components of the application. You can quickly update encryption for your application and ensure consistent security.

### Mgo Move

Mgo Move supports the following cryptographic hash functions:

- SHA2-256 as std::hash::sha2_256
- SHA3-256 as std::hash::sha3_256
- Keccak256 as mgo::hash::keccak256
- Blake2b-256 as mgo::hash::blake2b256

### Mgo Keys and Addresses

Mgo follows widely accepted wallet specifications in the cryptocurrency industry, including BIP-32 (and its variant SLIP-0010), BIP-44, and BIP-39, for easy key management by users. Currently, Mgo supports pure Ed25519, ECDSA Secp256k1, ECDSA Secp256r1, and multi-signature for signing transactions.

For wallets supporting the Ed25519 (EdDSA) signature scheme, Mgo follows SLIP-0010, which mandates wallets to derive child private keys from parent private keys and use hardened key paths.

For wallets supporting ECDSA Secp256k1 and ECDSA Secp256r1 signature schemes, Mgo follows BIP-32.

BIP-32 defines a hierarchical deterministic wallet structure logically associating a group of keys. Grouping keys in this way reduces the overhead of tracking a large number of private keys. This approach also allows a custodian to allocate different custody addresses to each user account from a controlled source. Separating private key derivation from public key derivation using BIP-32 enables view-only wallet use cases, where public key chains and their addresses can be derived while keeping private keys offline for signing.

#### Key Derivation Paths

BIP-44 further defines five levels of derivation paths and their exact meanings: m / purpose' / coin_type' / account' / change / address_index. In this structure, slashes represent new levels or sublevels in the hierarchy.

The purpose level is typically set to 44, corresponding to the BIP number. However, in Mgo, the purpose level is used to differentiate between different signature schemes: 44 for Ed25519, 54 for ECDSA Secp256k1, and 74 for Secp256r1. While setting the purpose level to a non-44 value is non-standard, the purpose field is commonly used to distinguish between different signature schemes. For example, BIP-49 and BIP-84 are used to identify script types in Bitcoin. Mgo has chosen 54 to represent ECDSA Secp256k1 to avoid confusion with any existing Bitcoin standard.

The coin_type values are managed by repositories of all other cryptocurrencies. Both signature schemes use Mgo's registered coin_type, which is 784.

The account level is typically used to logically separate user accounts and create specific account categories.

It is generally considered that currency based on accounts only defines the first three levels, and currency based on UTXO adds definitions for change and address levels. Because Mgo's object-oriented data model is neither UTXO-based nor account-based (it actually combines both), it uses all five levels for maximum compatibility.

| Scheme          | Path                                             | Comment                                       |
|-----------------|--------------------------------------------------|-----------------------------------------------|
| Ed25519         | m/44'/784'/`{account}`'/`{change}`'/`{address}`' | Each level of the derivation path is hardened |
| ECDSA Secp256k1 | m/54'/784'/`{account}`'/`{change}`'/`{address}`' | The first three levels are hardened           |
| ECDSA Secp256r1 | m/74'/784'/`{account}`'/`{change}`'/`{address}`' | The first three levels are hardened           |

#### Mnemonic Support

After defining deterministic methods for deriving master keys from seeds in Mgo, BIP-39 is introduced to use mnemonics to make seeds more readable and memorable. Mgo accepts 12, 15, 18, 21, and 24 words with appropriate checksums from the BIP-39 word list, corresponding to 128, 160, 192, 224, and 256 bits of entropy, respectively. Mgo wallets and SDKs provide a flexible interface for signing transactions with various signature schemes.

#### Address Format

To generate a 32-byte Mgo address, Mgo uses the BLAKE2b (256-bit output) hash function to hash the signature scheme flag 1 byte concatenated with the public key bytes. Mgo addresses currently support pure Ed25519, Secp256k1, Secp256r1, and MultiSig, with corresponding flag bytes of 0x00, 0x01, 0x02, and 0x03.
